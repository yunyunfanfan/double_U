import { BaseNavigation } from 'JhCommon';
import { router } from '@kit.ArkUI';
import { DeepSeekService } from '../../../services/deepseek/DeepSeekService';
import { LvMarkdownIn, lvText, lvTitle, lvCode, lvLink, LMICallBack } from '@luvi/lv-markdown-in';
import { userApiService, HealthDataRequest, RegisterResponse, RealtimeDataRequest } from '../../../services/api_network/UserApiService';

// å¥åº·æ•°æ®è§£æç»“æœç±»
class HealthDataParseResult {
  // å¥åº·æ•°æ®è¡¨å­—æ®µ
  steps: number = 0;
  steps_goal: number = 0;
  distance: number = 0;
  calories_burned: number = 0;
  current_heart_rate: number = 0;
  resting_heart_rate: number = 0;
  min_heart_rate: number = 0;
  avg_heart_rate: number = 0;
  max_heart_rate: number = 0;
  current_blood_oxygen: number = 0;
  min_blood_oxygen: number = 0;
  avg_blood_oxygen: number = 0;
  max_blood_oxygen: number = 0;
  sleep_score: number = 0;
  sleep_duration: number = 0;
  sleep_start_time: string = '';
  sleep_end_time: string = '';
  deep_sleep_duration: number = 0;
  light_sleep_duration: number = 0;
  rem_sleep_duration: number = 0;
  awake_duration: number = 0;
  active_calories: number = 0;
  calories_goal: number = 0;
  basic_metabolism_calories: number = 0;
  current_mood: number = -1;

  // å®æ—¶æ•°æ®ç›¸å…³
  realtime_entries: RealtimeEntry[] = [];
  userMessage: string = '';

  constructor() {}

  toString(): string {
    return `HealthDataParseResult{steps: ${this.steps}, heart_rate: ${this.current_heart_rate}, å®æ—¶æ•°æ®æ¡æ•°: ${this.realtime_entries.length}}`;
  }
}

// å®æ—¶æ•°æ®æ¡ç›®ç±»
class RealtimeEntry {
  time_stamp: string = '';
  data_type: string = '';
  value: number = 0;

  constructor(time_stamp: string, data_type: string, value: number) {
    this.time_stamp = time_stamp;
    this.data_type = data_type;
    this.value = value;
  }
}

// å¯¹è¯é¡¹ç±»
class ConversationItem {
  role: string = '';
  content: string = '';

  constructor(role: string, content: string) {
    this.role = role;
    this.content = content;
  }
}

// æ¶ˆæ¯ç±»
class Message {
  type: string = '';
  content: string = '';
  time: string = '';
  isStreaming: boolean = false;

  constructor(type: string, content: string, time: string, isStreaming?: boolean) {
    this.type = type;
    this.content = content;
    this.time = time;
    this.isStreaming = isStreaming || false;
  }

  toString(): string {
    return `Message{type: "${this.type}", contentLength: ${this.content.length}, isStreaming: ${this.isStreaming}}`;
  }
}

// æµå¼å¤„ç†çŠ¶æ€ç±»
class StreamProcessingState {
  isResponseComplete: boolean = false;
  isDataParsed: boolean = false;
  isDataSaved: boolean = false;
  lastProcessedLength: number = 0;
  userFriendlyMessage: string = '';
  completionCallbackExecuted: boolean = false;
  processingRequestId: string = '';

  constructor() {}

  reset(): void {
    this.isResponseComplete = false;
    this.isDataParsed = false;
    this.isDataSaved = false;
    this.lastProcessedLength = 0;
    this.userFriendlyMessage = '';
    this.completionCallbackExecuted = false;
    this.processingRequestId = Date.now().toString() + '_' + Math.random().toString(36).substr(2, 9);
  }
}

// AIä¿å­˜ç»“æœç±»
class AISaveResult {
  success: boolean = false;
  message: string = '';

  constructor(success: boolean, message: string) {
    this.success = success;
    this.message = message;
  }
}

@Entry
@Component
export struct HealthDataEntryPage {
  @State messages: Message[] = [];
  @State inputContent: string = '';
  @State isLoading: boolean = false;
  @State updateCounter: number = 0;
  @State isClearingDatabase: boolean = false;

  private conversation: ConversationItem[] = [];
  private cancelStream: (() => void) | null = null;
  private scrollerRef: Scroller = new Scroller();
  private inputController: TextInputController = new TextInputController();
  private streamState: StreamProcessingState = new StreamProcessingState();
  private currentUserId: number = 1;

  aboutToAppear(): void {
    this.loadCurrentUser();
    this.initializeSystem();
  }

  private loadCurrentUser(): void {
    try {
      const userInfoStr = AppStorage.get<string>('userInfo');
      if (userInfoStr) {
        interface UserInfoFromStorage {
          userId: string;
          userName: string;
          phone: string;
          loginTime: string;
        }
        const userInfo: UserInfoFromStorage = JSON.parse(userInfoStr) as UserInfoFromStorage;
        this.currentUserId = parseInt(userInfo.userId);
        console.info(`[AIå¥åº·å½•å…¥] å½“å‰ç”¨æˆ·ID: ${this.currentUserId}`);
      }
    } catch (error) {
      console.error(`[AIå¥åº·å½•å…¥] è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥:`, error);
    }
  }

  private async initializeSystem(): Promise<void> {
    const currentTime = new Date().toLocaleString('zh-CN');

    const welcomeMessage = new Message(
      'assistant',
      'æ‚¨å¥½ï¼æˆ‘æ˜¯å…¨é¢å¥åº·æ•°æ®å½•å…¥åŠ©æ‰‹ï¼Œæ”¯æŒè®°å½•æ­¥æ•°ã€å¿ƒç‡ã€è¡€æ°§ã€ç¡çœ ã€çƒ­é‡ã€å¿ƒæƒ…ç­‰æ‰€æœ‰å¥åº·æŒ‡æ ‡ï¼Œè¯·å‘Šè¯‰æˆ‘æ‚¨çš„å¥åº·æ•°æ®ã€‚',
      new Date().toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' })
    );

    this.messages = [welcomeMessage];

    const systemPrompt = this.buildComprehensiveSystemPrompt(currentTime);
    const systemConversation = new ConversationItem('system', systemPrompt);
    const assistantConversation = new ConversationItem('assistant', welcomeMessage.content);

    this.conversation = [systemConversation, assistantConversation];

    this.configureUITheme();
  }

  private buildComprehensiveSystemPrompt(currentTime: string): string {
    const currentDate = new Date();
    const currentWeekDay = currentDate.getDay();
    const weekDays = ['å‘¨æ—¥', 'å‘¨ä¸€', 'å‘¨äºŒ', 'å‘¨ä¸‰', 'å‘¨å››', 'å‘¨äº”', 'å‘¨å…­'];
    const todayWeekDay = weekDays[currentWeekDay];
    console.log(`${currentTime},${todayWeekDay}`)
    return `ä½ æ˜¯å…¨é¢å¥åº·æ•°æ®å½•å…¥åŠ©æ‰‹ï¼Œå½“å‰æ—¶é—´ï¼š${currentTime}ï¼Œä»Šå¤©æ˜¯${todayWeekDay}

ã€é‡è¦ã€‘å¯¹äºç”¨æˆ·æ²¡æœ‰æ˜ç¡®æåˆ°çš„æ•°æ®, è¯·ç•™ç©º, ä¸è¦æ“…è‡ªå¡«å…¥æ•°æ®
ä¾‹å¦‚ç”¨æˆ·åªå¡«å†™äº†å®æ—¶æ•°æ®, åªæåˆ°äº†æ­¥æ•°æ˜¯4000, é‚£ä¹ˆåœ¨å¥åº·æ•°æ®å½•å…¥å—åªæœ‰æ­¥æ•°æœ‰å€¼, å…¶ä½™ç©ºç€
å®æ—¶æ•°æ®å’Œå¥åº·æ•°æ®æ²¡æœ‰å…³è”! å½•å…¥å®æ—¶æ•°æ®å¹¶ä¸ä¼šæš—ç¤ºå¥åº·æ•°æ®, æ‰€ä»¥ä¸è¦é€šè¿‡å®æ—¶æ•°æ®ç¼–é€ å¥åº·æ•°æ®

ã€ä¸¥æ ¼æ ¼å¼è¦æ±‚ã€‘ä¸‰æ®µå¼å›å¤ï¼š

ç¬¬ä¸€æ®µï¼šæ•°æ®å½•å…¥å—
=== æ•°æ®å½•å…¥ ===
æ­¥æ•°:8000
æ­¥æ•°ç›®æ ‡:10000
è·ç¦»:5.2
æ€»çƒ­é‡:850
å½“å‰å¿ƒç‡:72
é™æ¯å¿ƒç‡:65
æœ€ä½å¿ƒç‡:60
å¹³å‡å¿ƒç‡:70
æœ€é«˜å¿ƒç‡:85
å½“å‰è¡€æ°§:98
æœ€ä½è¡€æ°§:95
å¹³å‡è¡€æ°§:97
æœ€é«˜è¡€æ°§:99
ç¡çœ è¯„åˆ†:85
ç¡çœ æ—¶é•¿:480
å…¥ç¡æ—¶é—´:23:30
èµ·åºŠæ—¶é—´:07:30
æ·±ç¡æ—¶é•¿:180
æµ…ç¡æ—¶é•¿:240
REMç¡çœ :60
æ¸…é†’æ—¶é•¿:30
æ´»åŠ¨çƒ­é‡:300
çƒ­é‡ç›®æ ‡:2000
åŸºç¡€ä»£è°¢:1550
å½“å‰å¿ƒæƒ…:7

ç¬¬äºŒæ®µï¼šåˆ†éš”ç¬¦
=== ç”¨æˆ·åé¦ˆ ===

ç¬¬ä¸‰æ®µï¼šç¡®è®¤ä¿¡æ¯
âœ… å…¨é¢å¥åº·æ•°æ®å·²ç²¾ç¡®ä¿å­˜ï¼
ğŸš¶ æ­¥æ•°ï¼š8000æ­¥ï¼ˆç›®æ ‡ï¼š10000æ­¥ï¼‰
ğŸ“ è·ç¦»ï¼š5.2å…¬é‡Œ
â¤ï¸ å¿ƒç‡ï¼šå½“å‰72ï¼Œé™æ¯65ï¼ŒèŒƒå›´60-85æ¬¡/åˆ†
ğŸ« è¡€æ°§ï¼šå½“å‰98%ï¼ŒèŒƒå›´95-99%
ğŸ˜´ ç¡çœ ï¼šè¯„åˆ†85åˆ†ï¼Œæ—¶é•¿8å°æ—¶ï¼Œæ·±ç¡3å°æ—¶
ğŸ”¥ çƒ­é‡ï¼šæ€»æ¶ˆè€—850åƒå¡ï¼ˆæ´»åŠ¨300+åŸºç¡€ä»£è°¢1550ï¼‰
ğŸ˜Š å¿ƒæƒ…ï¼š7åˆ†ï¼ˆæ»¡æ„çŠ¶æ€ï¼‰

ã€å…¨éƒ¨æ”¯æŒçš„æ•°æ®ç±»å‹ã€‘
åŸºç¡€æŒ‡æ ‡ï¼š
- æ­¥æ•°/æ­¥æ•°ç›®æ ‡ â†’ steps/steps_goalï¼ˆæ­¥ï¼‰
- è·ç¦» â†’ distanceï¼ˆå…¬é‡Œï¼‰
- æ€»çƒ­é‡ â†’ calories_burnedï¼ˆåƒå¡ï¼‰

å¿ƒç‡æ•°æ®ï¼š
- å½“å‰å¿ƒç‡ â†’ current_heart_rateï¼ˆæ¬¡/åˆ†ï¼‰
- é™æ¯å¿ƒç‡ â†’ resting_heart_rateï¼ˆæ¬¡/åˆ†ï¼‰
- æœ€ä½å¿ƒç‡ â†’ min_heart_rateï¼ˆæ¬¡/åˆ†ï¼‰
- å¹³å‡å¿ƒç‡ â†’ avg_heart_rateï¼ˆæ¬¡/åˆ†ï¼‰
- æœ€é«˜å¿ƒç‡ â†’ max_heart_rateï¼ˆæ¬¡/åˆ†ï¼‰

è¡€æ°§æ•°æ®ï¼š
- å½“å‰è¡€æ°§ â†’ current_blood_oxygenï¼ˆ%ï¼‰
- æœ€ä½è¡€æ°§ â†’ min_blood_oxygenï¼ˆ%ï¼‰
- å¹³å‡è¡€æ°§ â†’ avg_blood_oxygenï¼ˆ%ï¼‰
- æœ€é«˜è¡€æ°§ â†’ max_blood_oxygenï¼ˆ%ï¼‰

ç¡çœ æ•°æ®ï¼š
- ç¡çœ è¯„åˆ† â†’ sleep_scoreï¼ˆ0-100åˆ†ï¼‰
- ç¡çœ æ—¶é•¿ â†’ sleep_durationï¼ˆåˆ†é’Ÿï¼‰
- å…¥ç¡æ—¶é—´ â†’ sleep_start_timeï¼ˆHH:MMï¼‰
- èµ·åºŠæ—¶é—´ â†’ sleep_end_timeï¼ˆHH:MMï¼‰
- æ·±ç¡æ—¶é•¿ â†’ deep_sleep_durationï¼ˆåˆ†é’Ÿï¼‰
- æµ…ç¡æ—¶é•¿ â†’ light_sleep_durationï¼ˆåˆ†é’Ÿï¼‰
- REMç¡çœ  â†’ rem_sleep_durationï¼ˆåˆ†é’Ÿï¼‰
- æ¸…é†’æ—¶é•¿ â†’ awake_durationï¼ˆåˆ†é’Ÿï¼‰

çƒ­é‡æ•°æ®ï¼š
- æ´»åŠ¨çƒ­é‡ â†’ active_caloriesï¼ˆåƒå¡ï¼‰
- çƒ­é‡ç›®æ ‡ â†’ calories_goalï¼ˆåƒå¡ï¼‰
- åŸºç¡€ä»£è°¢ â†’ basic_metabolism_caloriesï¼ˆåƒå¡ï¼‰

å¿ƒæƒ…æ•°æ®ï¼š
- å½“å‰å¿ƒæƒ… â†’ current_moodï¼ˆ1-10åˆ†ï¼Œ-1è¡¨ç¤ºæœªè®¾ç½®ï¼‰

ã€æ•°å€¼ç²¾åº¦è¦æ±‚ã€‘
- è·ç¦»ï¼šä¿ç•™1ä½å°æ•°ï¼ˆå¦‚5.2ï¼‰
- æ—¶é—´ï¼šä½¿ç”¨HH:MMæ ¼å¼ï¼ˆå¦‚23:30ï¼‰
- å…¶ä»–æ•°å€¼ï¼šæ•´æ•°æˆ–ä¿æŒç”¨æˆ·è¾“å…¥ç²¾åº¦

ã€å…³é”®ã€‘æ‰€æœ‰æ•°å€¼å¿…é¡»ä¿æŒåŸå§‹ç²¾åº¦ï¼Œå‡†ç¡®è¯†åˆ«å¹¶åˆ†ç±»æ‰€æœ‰å¥åº·æ•°æ®ç±»å‹ï¼

ã€å®æ—¶æ•°æ®æ ¼å¼ã€‘
å½“ç”¨æˆ·æä¾›å¸¦æ—¶é—´çš„å…·ä½“æ•°æ®æ—¶ï¼Œé¢å¤–è¾“å‡ºå®æ—¶æ•°æ®å—ï¼š
=== å®æ—¶æ•°æ® ===
æ—¶é—´|ç±»å‹|æ•°å€¼
2025-06-14 18:00|heart_rate|88
2025-06-14 20:00|heart_rate|76
2025-06-13 16:00|blood_oxygen|96
2025-06-14 22:00|mood|3
2025-06-14 08:00|mood|7

ã€æ—¶é—´æˆ³æ ¼å¼è¦æ±‚ã€‘
- å¿…é¡»ä½¿ç”¨å®Œæ•´æ—¥æœŸæ—¶é—´æ ¼å¼ï¼šYYYY-MM-DD HH:MM
- æ ¹æ®ç”¨æˆ·è¾“å…¥åˆ¤æ–­å…·ä½“æ—¥æœŸï¼ˆä»Šå¤©ã€æ˜¨å¤©ç­‰ï¼‰
- é»˜è®¤ä¸ºå½“å‰æ—¥æœŸ

ã€å®æ—¶æ•°æ®ç±»å‹ã€‘
- heart_rateï¼ˆå¿ƒç‡ï¼‰
- blood_oxygenï¼ˆè¡€æ°§ï¼‰
- moodï¼ˆå¿ƒæƒ…ï¼Œ1-10åˆ†æ•°å€¼ï¼‰

ã€å¿ƒæƒ…æ•°å€¼å¯¹ç…§ã€‘
ç„¦è™‘>=0åˆ†ï¼Œç–²æƒ«>=2åˆ†ï¼Œå¹³é™>=4åˆ†ï¼Œæ»¡è¶³>=6åˆ†ï¼Œå¼€å¿ƒ>=8åˆ†ï¼Œé»˜è®¤=-1åˆ†
å¿ƒæƒ…å¿…é¡»ç›´æ¥è¾“å‡ºæ•°å€¼ï¼Œä¸è¦è¾“å‡ºæ–‡å­—ï¼

[æ³¨æ„]
åŒºåˆ†å¥½å®æ—¶æ•°æ®å’Œå¥åº·æ•°æ®, å¸¦æœ‰æ—¶é—´æˆ³çš„(å¿ƒç‡, è¡€æ°§, å¿ƒæƒ…)æ˜¯å®æ—¶æ•°æ®, å…¶ä»–çš„å‡ä¸ºå¥åº·æ•°æ®!
`;
  }

  private configureUITheme(): void {
    lvText.setTextSize(16);
    lvText.setTextLineHeight("24");
    lvTitle.setLevelTitleColor("#4CAF50");
    lvCode.setTheme("light");
    lvCode.setIndexState(true);
    lvLink.setTextColor("#4CAF50");
  }

  private parseHealthDataFromAI(aiResponse: string): HealthDataParseResult {
    console.info('[å…¨é¢å¥åº·æ•°æ®è§£æ] å¼€å§‹è§£æAIå›å¤');

    const result = new HealthDataParseResult();

    try {
      let dataPart = '';
      let userPart = '';

      if (aiResponse.includes('=== æ•°æ®å½•å…¥ ===') && aiResponse.includes('=== ç”¨æˆ·åé¦ˆ ===')) {
        const parts = aiResponse.split('=== ç”¨æˆ·åé¦ˆ ===');
        dataPart = parts[0].replace('=== æ•°æ®å½•å…¥ ===', '').trim();
        userPart = parts[1] ? parts[1].trim() : '';
      } else {
        dataPart = aiResponse;
        userPart = aiResponse;
      }

      console.info(`[å…¨é¢å¥åº·æ•°æ®è§£æ] æ•°æ®éƒ¨åˆ†: ${dataPart}`);

      // å®šä¹‰æ‰€æœ‰æ•°æ®ç±»å‹çš„åŒ¹é…æ¨¡å¼
      const patterns: Record<string, RegExp> = {
        // åŸºç¡€æŒ‡æ ‡
        'steps': /æ­¥æ•°[:ï¼š]\s*(\d+)/,
        'steps_goal': /æ­¥æ•°ç›®æ ‡[:ï¼š]\s*(\d+)/,
        'distance': /è·ç¦»[:ï¼š]\s*([\d.]+)/,
        'calories_burned': /æ€»çƒ­é‡[:ï¼š]\s*([\d.]+)/,

        // å¿ƒç‡æ•°æ®
        'current_heart_rate': /å½“å‰å¿ƒç‡[:ï¼š]\s*(\d+)/,
        'resting_heart_rate': /é™æ¯å¿ƒç‡[:ï¼š]\s*(\d+)/,
        'min_heart_rate': /æœ€ä½å¿ƒç‡[:ï¼š]\s*(\d+)/,
        'avg_heart_rate': /å¹³å‡å¿ƒç‡[:ï¼š]\s*(\d+)/,
        'max_heart_rate': /æœ€é«˜å¿ƒç‡[:ï¼š]\s*(\d+)/,

        // è¡€æ°§æ•°æ®
        'current_blood_oxygen': /å½“å‰è¡€æ°§[:ï¼š]\s*(\d+)/,
        'min_blood_oxygen': /æœ€ä½è¡€æ°§[:ï¼š]\s*(\d+)/,
        'avg_blood_oxygen': /å¹³å‡è¡€æ°§[:ï¼š]\s*(\d+)/,
        'max_blood_oxygen': /æœ€é«˜è¡€æ°§[:ï¼š]\s*(\d+)/,

        // ç¡çœ æ•°æ®
        'sleep_score': /ç¡çœ è¯„åˆ†[:ï¼š]\s*(\d+)/,
        'sleep_duration': /ç¡çœ æ—¶é•¿[:ï¼š]\s*(\d+)/,
        'sleep_start_time': /å…¥ç¡æ—¶é—´[:ï¼š]\s*(\d{1,2}:\d{2})/,
        'sleep_end_time': /èµ·åºŠæ—¶é—´[:ï¼š]\s*(\d{1,2}:\d{2})/,
        'deep_sleep_duration': /æ·±ç¡æ—¶é•¿[:ï¼š]\s*(\d+)/,
        'light_sleep_duration': /æµ…ç¡æ—¶é•¿[:ï¼š]\s*(\d+)/,
        'rem_sleep_duration': /REMç¡çœ [:ï¼š]\s*(\d+)/,
        'awake_duration': /æ¸…é†’æ—¶é•¿[:ï¼š]\s*(\d+)/,

        // çƒ­é‡æ•°æ®
        'active_calories': /æ´»åŠ¨çƒ­é‡[:ï¼š]\s*([\d.]+)/,
        'calories_goal': /çƒ­é‡ç›®æ ‡[:ï¼š]\s*([\d.]+)/,
        'basic_metabolism_calories': /åŸºç¡€ä»£è°¢[:ï¼š]\s*([\d.]+)/,

        // å¿ƒæƒ…æ•°æ®
        'current_mood': /å½“å‰å¿ƒæƒ…[:ï¼š]\s*(\d+)/
      };

      // è§£ææ‰€æœ‰åŒ¹é…çš„æ•°æ®
      Object.keys(patterns).forEach((key: string) => {
        const match = dataPart.match(patterns[key]);
        if (match) {
          const valueStr = match[1];

          if (key === 'sleep_start_time' || key === 'sleep_end_time') {
            // æ—¶é—´å­—æ®µç›´æ¥èµ‹å€¼å­—ç¬¦ä¸²
            if (key === 'sleep_start_time') {
              result.sleep_start_time = valueStr;
            } else if (key === 'sleep_end_time') {
              result.sleep_end_time = valueStr;
            }
            console.info(`[å…¨é¢å¥åº·æ•°æ®è§£æ] æå–${key}: ${valueStr}`);
          } else {
            // æ•°å€¼å­—æ®µè½¬æ¢ä¸ºæ•°å­—
            const value = parseFloat(valueStr);
            if (!isNaN(value)) {
              switch (key) {
                case 'steps': result.steps = Math.floor(value); break;
                case 'steps_goal': result.steps_goal = Math.floor(value); break;
                case 'distance': result.distance = value; break;
                case 'calories_burned': result.calories_burned = value; break;
                case 'current_heart_rate': result.current_heart_rate = Math.floor(value); break;
                case 'resting_heart_rate': result.resting_heart_rate = Math.floor(value); break;
                case 'min_heart_rate': result.min_heart_rate = Math.floor(value); break;
                case 'avg_heart_rate': result.avg_heart_rate = Math.floor(value); break;
                case 'max_heart_rate': result.max_heart_rate = Math.floor(value); break;
                case 'current_blood_oxygen': result.current_blood_oxygen = Math.floor(value); break;
                case 'min_blood_oxygen': result.min_blood_oxygen = Math.floor(value); break;
                case 'avg_blood_oxygen': result.avg_blood_oxygen = Math.floor(value); break;
                case 'max_blood_oxygen': result.max_blood_oxygen = Math.floor(value); break;
                case 'sleep_score': result.sleep_score = Math.floor(value); break;
                case 'sleep_duration': result.sleep_duration = Math.floor(value); break;
                case 'deep_sleep_duration': result.deep_sleep_duration = Math.floor(value); break;
                case 'light_sleep_duration': result.light_sleep_duration = Math.floor(value); break;
                case 'rem_sleep_duration': result.rem_sleep_duration = Math.floor(value); break;
                case 'awake_duration': result.awake_duration = Math.floor(value); break;
                case 'active_calories': result.active_calories = value; break;
                case 'calories_goal': result.calories_goal = value; break;
                case 'basic_metabolism_calories': result.basic_metabolism_calories = value; break;
                case 'current_mood': result.current_mood = Math.floor(value); break;
              }
              console.info(`[å…¨é¢å¥åº·æ•°æ®è§£æ] æå–${key}: ${value}`);
            }
          }
        }
      });

      // è§£æå®æ—¶æ•°æ®
      if (aiResponse.includes('=== å®æ—¶æ•°æ® ===')) {
        const realtimeMatch = aiResponse.match(/=== å®æ—¶æ•°æ® ===([\s\S]*?)(?===|$)/);
        if (realtimeMatch) {
          const realtimeSection = realtimeMatch[1].trim();
          console.info(`[å®æ—¶æ•°æ®è§£æ] å®æ—¶æ•°æ®éƒ¨åˆ†: ${realtimeSection}`);
          const lines = realtimeSection.split('\n');
          for (const line of lines) {
            const trimmedLine = line.trim();
            if (trimmedLine.includes('|') && !trimmedLine.includes('æ—¶é—´|ç±»å‹|æ•°å€¼')) {
              const parts = trimmedLine.split('|');
              if (parts.length === 3) {
                const timeStamp = parts[0].trim();
                const dataType = parts[1].trim();
                const valueStr = parts[2].trim();

                let value: number;
                if (dataType === 'mood') {
                  // å¿ƒæƒ…æ•°æ®å¤„ç†ï¼šä¼˜å…ˆè§£ææ•°å€¼ï¼Œå¦‚æœæ˜¯æ–‡å­—åˆ™è½¬æ¢
                  const numValue = parseFloat(valueStr);
                  if (!isNaN(numValue)) {
                    value = numValue;
                  } else {
                    switch (valueStr) {
                      case 'ç„¦è™‘': value = 0; break;
                      case 'ç–²æƒ«': value = 2; break;
                      case 'å¹³é™': value = 4; break;
                      case 'æ»¡è¶³': value = 6; break;
                      case 'å¼€å¿ƒ': value = 8; break;
                      default: value = -1; break;
                    }
                  }
                } else {
                  value = parseFloat(valueStr);
                }

                if (!isNaN(value) && timeStamp.includes(':')) {
                  result.realtime_entries.push(new RealtimeEntry(timeStamp, dataType, value));
                  console.info(`[å®æ—¶æ•°æ®è§£æ] æå–å®æ—¶æ•°æ®: ${timeStamp} ${dataType} ${value}`);
                }
              }
            }
          }
        }
      }

      result.userMessage = userPart || 'å…¨é¢å¥åº·æ•°æ®å½•å…¥å®Œæˆ';

      console.info(`[å…¨é¢å¥åº·æ•°æ®è§£æ] è§£æç»“æœ: ${result.toString()}`);
      return result;

    } catch (error) {
      console.error('[å…¨é¢å¥åº·æ•°æ®è§£æ] è§£æå¼‚å¸¸:', error);
      result.userMessage = aiResponse;
      return result;
    }
  }

  private async saveHealthDataToBackend(parseResult: HealthDataParseResult): Promise<AISaveResult> {
    try {
      console.info('[åç«¯ä¿å­˜] å¼€å§‹ä¿å­˜å…¨é¢å¥åº·æ•°æ®åˆ°åç«¯');
      console.info(`å¿ƒæƒ…æ•°å­—: ${parseResult.current_mood}`)
      const todayDate = new Date();
      const currentDate: string = `${todayDate.getFullYear()}-${String(todayDate.getMonth() + 1).padStart(2, '0')}-${String(todayDate.getDate()).padStart(2, '0')}`;

      // æ„å»ºå¥åº·æ•°æ®è¯·æ±‚
      const healthDataRequest: HealthDataRequest = {
        user_id: this.currentUserId,
        record_date: currentDate,
        steps: parseResult.steps || undefined,
        steps_goal: parseResult.steps_goal || undefined,
        distance: parseResult.distance || undefined,
        calories_burned: parseResult.calories_burned || undefined,
        current_heart_rate: parseResult.current_heart_rate || undefined,
        resting_heart_rate: parseResult.resting_heart_rate || undefined,
        min_heart_rate: parseResult.min_heart_rate || undefined,
        avg_heart_rate: parseResult.avg_heart_rate || undefined,
        max_heart_rate: parseResult.max_heart_rate || undefined,
        current_blood_oxygen: parseResult.current_blood_oxygen || undefined,
        min_blood_oxygen: parseResult.min_blood_oxygen || undefined,
        avg_blood_oxygen: parseResult.avg_blood_oxygen || undefined,
        max_blood_oxygen: parseResult.max_blood_oxygen || undefined,
        sleep_score: parseResult.sleep_score || undefined,
        sleep_duration: parseResult.sleep_duration || undefined,
        sleep_start_time: parseResult.sleep_start_time || undefined,
        sleep_end_time: parseResult.sleep_end_time || undefined,
        deep_sleep_duration: parseResult.deep_sleep_duration || undefined,
        light_sleep_duration: parseResult.light_sleep_duration || undefined,
        rem_sleep_duration: parseResult.rem_sleep_duration || undefined,
        awake_duration: parseResult.awake_duration || undefined,
        active_calories: parseResult.active_calories || undefined,
        calories_goal: parseResult.calories_goal || undefined,
        basic_metabolism_calories: parseResult.basic_metabolism_calories || undefined,
        current_mood: parseResult.current_mood !== -1 ? parseResult.current_mood : -1
      };

      let healthResponse: RegisterResponse = { success: true, message: 'è·³è¿‡å¥åº·æ•°æ®ä¿å­˜' };

      // åˆ¤æ–­æ˜¯å¦ä¸ºçº¯å®æ—¶æ•°æ®å½•å…¥
      const isPureRealtimeData = parseResult.realtime_entries.length > 0 &&
        parseResult.steps === 0 && parseResult.current_heart_rate === 0 &&
        parseResult.current_blood_oxygen === 0 && parseResult.current_mood === -1;

      if (!isPureRealtimeData) {
        // åªæœ‰éçº¯å®æ—¶æ•°æ®æ—¶æ‰ä¿å­˜å¥åº·æ•°æ®
        healthResponse = await userApiService.saveHealthData(healthDataRequest);
      }

      // å¦‚æœæœ‰å®æ—¶æ•°æ®ï¼Œä¿å­˜å®æ—¶æ•°æ®
      if (parseResult.realtime_entries.length > 0) {
        console.info(`[åç«¯ä¿å­˜] ä¿å­˜${parseResult.realtime_entries.length}æ¡å®æ—¶æ•°æ®`);

        for (const entry of parseResult.realtime_entries) {
          const realtimeRequest: RealtimeDataRequest = {
            user_id: this.currentUserId,
            record_date: currentDate,
            time_stamp: entry.time_stamp,
            data_type: entry.data_type,
            value: entry.value
          };

          await userApiService.saveRealtimeData(realtimeRequest);
        }
      }

      console.info(`[åç«¯ä¿å­˜] å¥åº·æ•°æ®ä¿å­˜ç»“æœ: ${healthResponse.success}`);
      return new AISaveResult(healthResponse.success, healthResponse.message);

    } catch (error) {
      console.error('[åç«¯ä¿å­˜] ä¿å­˜å¼‚å¸¸:', error);
      const errorMessage = error instanceof Error ? error.message : 'ç½‘ç»œè¿æ¥å¤±è´¥';
      return new AISaveResult(false, `ä¿å­˜å¤±è´¥: ${errorMessage}`);
    }
  }

  private scrollToBottom(): void {
    setTimeout(() => {
      try {
        this.scrollerRef.scrollEdge(Edge.Bottom);
      } catch (err) {
        console.error('[æ»šåŠ¨] æ»šåŠ¨åˆ°åº•éƒ¨å¤±è´¥:', err);
      }
    }, 100);
  }

  private sendToAI(userMessage: string): void {
    try {
      this.streamState.reset();

      const currentTime = new Date().toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
      const userMsg = new Message('user', userMessage, currentTime);
      this.messages.push(userMsg);
      this.scrollToBottom();

      const fullCurrentTime = new Date().toLocaleString('zh-CN');
      const contextualMessage = `å½“å‰æ—¶é—´ï¼š${fullCurrentTime}\nå…¨é¢å¥åº·æ•°æ®ï¼ˆæ”¯æŒæ‰€æœ‰ç±»å‹ï¼‰ï¼š${userMessage}`;

      const newConversation = new ConversationItem('user', contextualMessage);
      this.conversation.push(newConversation);

      const aiMessageIndex = this.messages.length;
      const aiMsg = new Message(
        'assistant',
        'æ­£åœ¨å…¨é¢åˆ†ææ‚¨çš„å¥åº·æ•°æ®...',
        new Date().toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' }),
        true
      );
      this.messages.push(aiMsg);
      this.scrollToBottom();

      let fullAIResponse = '';

      this.cancelStream = DeepSeekService.streamRequest(
        contextualMessage,
        this.conversation,

        (chunk: string) => {
          fullAIResponse = chunk;
          const parseResult = this.parseHealthDataFromAI(fullAIResponse);
          if (parseResult.userMessage) {
            this.messages[aiMessageIndex].content = parseResult.userMessage;
            this.updateCounter++;
            this.messages = [...this.messages];
          }
        },

        async () => {
          if (this.streamState.completionCallbackExecuted) {
            return;
          }

          this.streamState.completionCallbackExecuted = true;
          this.isLoading = false;

          if (this.messages[aiMessageIndex]) {
            this.messages[aiMessageIndex].isStreaming = false;
          }

          const parseResult = this.parseHealthDataFromAI(fullAIResponse);
          const saveResult = await this.saveHealthDataToBackend(parseResult);

          let finalMessage = parseResult.userMessage;
          if (saveResult.success) {
            finalMessage += '\n\nâœ… å…¨é¢å¥åº·æ•°æ®å·²æˆåŠŸä¿å­˜åˆ°æ•°æ®åº“';
          } else {
            finalMessage += `\n\nâŒ æ•°æ®ä¿å­˜å¤±è´¥: ${saveResult.message}`;
          }

          this.messages[aiMessageIndex].content = finalMessage;

          const assistantConversation = new ConversationItem('assistant', fullAIResponse);
          this.conversation.push(assistantConversation);

          this.updateCounter++;
          this.messages = [...this.messages];
          this.cancelStream = null;
          this.scrollToBottom();
        },

        (error: Error) => {
          this.isLoading = false;
          if (this.messages[aiMessageIndex]) {
            this.messages[aiMessageIndex].content = `åˆ†æå¤±è´¥: ${error.message}`;
            this.messages[aiMessageIndex].isStreaming = false;
          }

          this.updateCounter++;
          this.messages = [...this.messages];
          this.cancelStream = null;
          this.scrollToBottom();
          this.streamState.reset();
        }
      );
    } catch (err) {
      console.error('[AIå‘é€] å‘é€å¼‚å¸¸:', err);
      this.isLoading = false;
      this.streamState.reset();
      this.scrollToBottom();
    }
  }

  build() {
    Column() {
      // å¯¼èˆªæ 
      Row() {
        Button({ type: ButtonType.Circle }) {
          Image($r('app.media.ic_back')).width(24).height(24)
        }
        .onClick(() => {
          try {
            router.back();
          } catch (err) {
            console.error('[å¯¼èˆª] è¿”å›å¤±è´¥:', err);
          }
        })
        .width(44).height(44).backgroundColor(Color.Transparent).margin({ left: 12 })

        Text('AIå…¨é¢å¥åº·æ•°æ®å½•å…¥').fontSize(20).fontWeight(FontWeight.Bold).fontColor('#333333')
          .layoutWeight(1).textAlign(TextAlign.Center)

        Button({ type: ButtonType.Circle }) {
          if (this.isClearingDatabase) {
            LoadingProgress().width(20).height(20).color('#FF5722')
          } else {
            Text('ğŸ—‘ï¸').fontSize(18)
          }
        }
        .onClick(() => {
          if (!this.isClearingDatabase) {
            this.messages = this.messages.slice(0, 1);
            this.conversation = this.conversation.slice(0, 2);
            this.updateCounter++;
          }
        })
        .enabled(!this.isClearingDatabase && !this.isLoading)
        .width(44).height(44).backgroundColor(Color.Transparent).margin({ right: 12 })
        .opacity(this.isClearingDatabase ? 0.6 : 1.0)
      }
      .width('100%').height(64).justifyContent(FlexAlign.SpaceBetween)
      .backgroundColor('#FFFFFF').shadow({ radius: 8, color: 'rgba(0,0,0,0.05)', offsetY: 2 })

      Scroll(this.scrollerRef) {
        Column() {
          ForEach(this.messages, (msg: Message, index: number) => {
            Row() {
              if (msg.type === 'assistant') {
                Image($r('app.media.ic_service'))
                  .width(36).height(36).borderRadius(18)
                  .backgroundColor('#E8F5E8').padding(6)

                Column() {
                  Text(msg.time).fontSize(12).fontColor('#999').margin({ bottom: 4 })

                  LvMarkdownIn({
                    text: msg.content || 'æ­£åœ¨å…¨é¢åˆ†ææ‚¨çš„å¥åº·æ•°æ®...',
                    loadMode: "text",
                    loadCallBack: {
                      success: (r: LMICallBack) => {
                        setTimeout(() => { this.scrollToBottom(); }, 50);
                      },
                      fail: (r: LMICallBack) => {
                        console.error('[Markdown] åŠ è½½å¤±è´¥');
                      }
                    }
                  })
                    .backgroundColor('#fff').borderRadius(16).padding(16)
                    .shadow({ radius: 3, color: '#E8F5E8', offsetY: 2 }).width('100%')

                  if (msg.isStreaming) {
                    Row() {
                      Text('æ­£åœ¨åˆ†æä¸­').fontSize(12).fontColor('#4CAF50').margin({ right: 8 })
                      ForEach([1, 2, 3], (i: number) => {
                        Text('â—').fontSize(14).fontColor('#4CAF50').opacity(0.3 + (i * 0.3))
                      })
                    }.width('100%').margin({ top: 8 })
                  }
                }.margin({ left: 10 }).width('82%')

                Blank()
              } else {
                Blank()

                Column() {
                  Text(msg.time).fontSize(12).fontColor('#999').margin({ bottom: 4 })
                  Text(msg.content).fontSize(16).fontColor('#fff').backgroundColor('#4CAF50')
                    .borderRadius(16).padding(16).lineHeight(24)
                }.margin({ right: 10 }).width('82%')

                Image($r('app.media.ic_user'))
                  .width(36).height(36).borderRadius(18)
                  .backgroundColor('#C8E6C9').padding(6)
              }
            }
            .width('100%').justifyContent(msg.type === 'user' ? FlexAlign.End : FlexAlign.Start)
            .padding({ left: 16, right: 16, top: 12, bottom: 12 })
          })
        }.width('100%').padding({ top: 12, bottom: 12 })
      }
      .layoutWeight(1).backgroundColor('#F8FFF8').scrollBar(BarState.Auto)

      if (this.isLoading) {
        Row() {
          LoadingProgress().width(28).height(28).color('#4CAF50')
          Text('æ­£åœ¨å…¨é¢åˆ†ææ‚¨çš„å¥åº·æ•°æ®...').fontSize(14).fontColor('#4CAF50').margin({ left: 12 })
        }
        .justifyContent(FlexAlign.Center).width('100%').padding(12)
        .backgroundColor('#F0F8F0').borderRadius(8).margin({ left: 16, right: 16, bottom: 8 })
      }

      Row() {
        TextInput({
          placeholder: 'è¯·è¾“å…¥å®Œæ•´å¥åº·æ•°æ®ï¼Œæ”¯æŒæ­¥æ•°ã€å¿ƒç‡ã€è¡€æ°§ã€ç¡çœ ã€çƒ­é‡ã€å¿ƒæƒ…ç­‰æ‰€æœ‰æŒ‡æ ‡...',
          text: this.inputContent,
          controller: this.inputController
        })
          .backgroundColor('#fff').borderRadius(24).border({ width: 1, color: '#4CAF50' })
          .padding({ left: 16, right: 16, top: 12, bottom: 12 }).fontSize(16).layoutWeight(1)
          .onChange((v: string) => {
            this.inputContent = v;
          })
          .enabled(!this.isLoading && !this.isClearingDatabase)
          .onSubmit(() => {
            if (this.inputContent && !this.isLoading && !this.isClearingDatabase) {
              const userMessage = this.inputContent;
              this.inputContent = '';
              this.isLoading = true;
              this.sendToAI(userMessage);
            }
          })

        Button({ type: ButtonType.Circle }) {
          Image(this.cancelStream ? $r('app.media.ic_stop') : $r('app.media.ic_send'))
            .width(24).height(24).fillColor(Color.White)
        }
        .onClick(() => {
          if (this.cancelStream) {
            this.cancelStream();
            this.cancelStream = null;
            this.isLoading = false;
            this.streamState.reset();
          } else {
            if (!this.inputContent || this.isLoading || this.isClearingDatabase) return;

            const userMessage = this.inputContent;
            this.inputContent = '';
            this.isLoading = true;
            this.sendToAI(userMessage);
          }
        })
        .enabled(!this.isClearingDatabase)
        .backgroundColor(this.cancelStream ? '#FF5252' : '#4CAF50').borderRadius(24)
        .width(50).height(50).margin({ left: 12 })
      }
      .padding(16).backgroundColor('#F8FFF8').border({ width: { top: 1 }, color: '#E8F5E8' })
    }
    .backgroundColor('#F8FFF8').height('100%')
  }
}